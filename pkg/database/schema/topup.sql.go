// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: topup.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createTopup = `-- name: CreateTopup :one
INSERT INTO
    topups (
        card_number,
        topup_amount,
        topup_method,
        topup_time,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        current_timestamp,
        current_timestamp
    ) RETURNING topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at
`

type CreateTopupParams struct {
	CardNumber  string    `json:"card_number"`
	TopupAmount int32     `json:"topup_amount"`
	TopupMethod string    `json:"topup_method"`
	TopupTime   time.Time `json:"topup_time"`
}

// CreateTopup: Inserts a new topup transaction into the topups table
// Purpose: Used when a user performs a topup action
// Parameters:
//
//	$1: card_number - The card number receiving the topup
//	$2: topup_amount - Amount of the topup
//	$3: topup_method - Payment method used (e.g., 'e-wallet', 'bank_transfer')
//	$4: topup_time - Timestamp of the actual topup transaction
//
// Returns:
//
//	Full topup record including auto-generated fields
//
// Business Logic:
//   - Automatically sets created_at and updated_at to current timestamp
func (q *Queries) CreateTopup(ctx context.Context, arg CreateTopupParams) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, createTopup,
		arg.CardNumber,
		arg.TopupAmount,
		arg.TopupMethod,
		arg.TopupTime,
	)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentTopups = `-- name: DeleteAllPermanentTopups :exec
DELETE FROM topups
WHERE
    deleted_at IS NOT NULL
`

// DeleteAllPermanentTopups: Permanently deletes all soft-deleted topups
// Purpose: Bulk cleanup of trashed topup records
// Business Logic:
//   - Cannot be undone; this is a hard delete
//   - Use for permanent data purging
func (q *Queries) DeleteAllPermanentTopups(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentTopups)
	return err
}

const deleteTopupPermanently = `-- name: DeleteTopupPermanently :exec
DELETE FROM topups WHERE topup_id = $1
`

// DeleteTopupPermanently: Permanently deletes a topup record from the database
// Purpose: Irrecoverably removes topup data
// Parameters:
//
//	$1: topup_id - ID of the topup to delete
//
// Business Logic:
//   - No soft-delete; data is permanently erased
//   - Use with caution
func (q *Queries) DeleteTopupPermanently(ctx context.Context, topupID int32) error {
	_, err := q.db.ExecContext(ctx, deleteTopupPermanently, topupID)
	return err
}

const getActiveTopups = `-- name: GetActiveTopups :many
SELECT
    topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    topups
WHERE
    deleted_at IS NULL
    AND (
        $1::TEXT IS NULL
        OR card_number ILIKE '%' || $1 || '%'
        OR topup_no::TEXT ILIKE '%' || $1 || '%'
        OR topup_method ILIKE '%' || $1 || '%'
    )
ORDER BY
    topup_time DESC
LIMIT $2 OFFSET $3
`

type GetActiveTopupsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveTopupsRow struct {
	TopupID     int32        `json:"topup_id"`
	TopupNo     uuid.UUID    `json:"topup_no"`
	CardNumber  string       `json:"card_number"`
	TopupAmount int32        `json:"topup_amount"`
	TopupMethod string       `json:"topup_method"`
	TopupTime   time.Time    `json:"topup_time"`
	Status      string       `json:"status"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// GetActiveTopups: Retrieves paginated list of active (non-deleted) topups with search
// Purpose: Display only active topups for admin or user dashboards
// Parameters:
//
//	$1: search_term - Optional text to filter by card_number, topup_no, or topup_method
//	$2: limit - Max records to return
//	$3: offset - Number of rows to skip
//
// Returns:
//
//	All active topup fields and total_count
//
// Business Logic:
//   - Filters out soft-deleted topups (deleted_at IS NULL)
//   - Supports partial, case-insensitive search across multiple fields
//   - Results sorted by topup_time (most recent first)
//   - total_count is used for frontend pagination
func (q *Queries) GetActiveTopups(ctx context.Context, arg GetActiveTopupsParams) ([]*GetActiveTopupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTopups, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveTopupsRow
	for rows.Next() {
		var i GetActiveTopupsRow
		if err := rows.Scan(
			&i.TopupID,
			&i.TopupNo,
			&i.CardNumber,
			&i.TopupAmount,
			&i.TopupMethod,
			&i.TopupTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTopupStatusFailed = `-- name: GetMonthTopupStatusFailed :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        EXTRACT(MONTH FROM t.topup_time)::integer AS month,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'failed'
        AND (
            (t.topup_time >= $1::timestamp AND t.topup_time <= $2::timestamp)
            OR (t.topup_time >= $3::timestamp AND t.topup_time <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time),
        EXTRACT(MONTH FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_failed,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthTopupStatusFailedParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthTopupStatusFailedRow struct {
	Year        string `json:"year"`
	Month       string `json:"month"`
	TotalFailed int64  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthTopupStatusFailed: Retrieves monthly failed metrics for topups
// Purpose: Analyze failedful topup trends across comparison periods
// Parameters:
//
//	$1: period1_start - Start date of first comparison period
//	$2: period1_end - End date of first comparison period
//	$3: period2_start - Start date of second comparison period
//	$4: period2_end - End date of second comparison period
//
// Returns:
//
//	year: Year as text (e.g., '2023')
//	month: 3-letter month abbreviation (e.g., 'Jan')
//	total_failed: Count of failedful topups
//	total_amount: Sum of failedful topup amounts
//
// Business Logic:
//   - Only includes failedful topups (status = 'failed')
//   - Covers two customizable time periods for comparison
//   - Zero-fills months with no activity
//   - Formats output for consistent visualization
//   - Orders by year and month (newest first)
//   - Useful for identifying seasonal topup patterns
func (q *Queries) GetMonthTopupStatusFailed(ctx context.Context, arg GetMonthTopupStatusFailedParams) ([]*GetMonthTopupStatusFailedRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthTopupStatusFailed,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthTopupStatusFailedRow
	for rows.Next() {
		var i GetMonthTopupStatusFailedRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalFailed,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTopupStatusFailedCardNumber = `-- name: GetMonthTopupStatusFailedCardNumber :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        EXTRACT(MONTH FROM t.topup_time)::integer AS month,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'failed'
        AND t.card_number = $1
        AND (
            (t.topup_time >= $2::timestamp AND t.topup_time <= $3::timestamp)
            OR (t.topup_time >= $4::timestamp AND t.topup_time <= $5::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time),
        EXTRACT(MONTH FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_failed,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $2::timestamp)::text AS year,
        TO_CHAR($2::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $2::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $2::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $4::timestamp)::text AS year,
        TO_CHAR($4::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $4::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $4::timestamp)::integer
    )
)
SELECT year, month, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthTopupStatusFailedCardNumberParams struct {
	CardNumber string    `json:"card_number"`
	Column2    time.Time `json:"column_2"`
	Column3    time.Time `json:"column_3"`
	Column4    time.Time `json:"column_4"`
	Column5    time.Time `json:"column_5"`
}

type GetMonthTopupStatusFailedCardNumberRow struct {
	Year        string `json:"year"`
	Month       string `json:"month"`
	TotalFailed int64  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthTopupStatusFailedCardNumber: Retrieves monthly failed metrics for topups
// Purpose: Analyze failedful topup trends across comparison periods
// Parameters:
//
//	$1: card_number       - Optional filter by card_number (NULL to ignore filter)
//	$2: period1_start - Start date of first comparison period
//	$3: period1_end - End date of first comparison period
//	$4: period2_start - Start date of second comparison period
//	$5: period2_end - End date of second comparison period
//
// Returns:
//
//	year: Year as text (e.g., '2023')
//	month: 3-letter month abbreviation (e.g., 'Jan')
//	total_failed: Count of failedful topups
//	total_amount: Sum of failedful topup amounts
//
// Business Logic:
//   - Only includes failedful topups (status = 'failed')
//   - Covers two customizable time periods for comparison
//   - Zero-fills months with no activity
//   - Formats output for consistent visualization
//   - Orders by year and month (newest first)
//   - Useful for identifying seasonal topup patterns
func (q *Queries) GetMonthTopupStatusFailedCardNumber(ctx context.Context, arg GetMonthTopupStatusFailedCardNumberParams) ([]*GetMonthTopupStatusFailedCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthTopupStatusFailedCardNumber,
		arg.CardNumber,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthTopupStatusFailedCardNumberRow
	for rows.Next() {
		var i GetMonthTopupStatusFailedCardNumberRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalFailed,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTopupStatusSuccess = `-- name: GetMonthTopupStatusSuccess :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        EXTRACT(MONTH FROM t.topup_time)::integer AS month,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'success'
        AND (
            (t.topup_time >= $1::timestamp AND t.topup_time <= $2::timestamp)
            OR (t.topup_time >= $3::timestamp AND t.topup_time <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time),
        EXTRACT(MONTH FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_success,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthTopupStatusSuccessParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthTopupStatusSuccessRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalSuccess int64  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

// GetMonthTopupStatusSuccess: Retrieves monthly success metrics for topups
// Purpose: Analyze successful topup trends across comparison periods
// Parameters:
//
//	$1: period1_start - Start date of first comparison period
//	$2: period1_end - End date of first comparison period
//	$3: period2_start - Start date of second comparison period
//	$4: period2_end - End date of second comparison period
//
// Returns:
//
//	year: Year as text (e.g., '2023')
//	month: 3-letter month abbreviation (e.g., 'Jan')
//	total_success: Count of successful topups
//	total_amount: Sum of successful topup amounts
//
// Business Logic:
//   - Only includes successful topups (status = 'success')
//   - Covers two customizable time periods for comparison
//   - Zero-fills months with no activity
//   - Formats output for consistent visualization
//   - Orders by year and month (newest first)
//   - Useful for identifying seasonal topup patterns
func (q *Queries) GetMonthTopupStatusSuccess(ctx context.Context, arg GetMonthTopupStatusSuccessParams) ([]*GetMonthTopupStatusSuccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthTopupStatusSuccess,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthTopupStatusSuccessRow
	for rows.Next() {
		var i GetMonthTopupStatusSuccessRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalSuccess,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTopupStatusSuccessCardNumber = `-- name: GetMonthTopupStatusSuccessCardNumber :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        EXTRACT(MONTH FROM t.topup_time)::integer AS month,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'success'
        AND t.card_number = $1
        AND (
            (t.topup_time >= $2::timestamp AND t.topup_time <= $3::timestamp)
            OR (t.topup_time >= $4::timestamp AND t.topup_time <= $5::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time),
        EXTRACT(MONTH FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_success,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $2::timestamp)::text AS year,
        TO_CHAR($2::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $2::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $2::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthTopupStatusSuccessCardNumberParams struct {
	CardNumber string    `json:"card_number"`
	Column2    time.Time `json:"column_2"`
	Column3    time.Time `json:"column_3"`
	Column4    time.Time `json:"column_4"`
	Column5    time.Time `json:"column_5"`
}

type GetMonthTopupStatusSuccessCardNumberRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalSuccess int64  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

// GetMonthTopupStatusSuccessCardNumber: Retrieves monthly success metrics for topups
// Purpose: Analyze successful topup trends across comparison periods
// Parameters:
//
//	$1: card_number       - Optional filter by card_number (NULL to ignore filter)
//	$2: period1_start - Start date of first comparison period
//	$3: period1_end - End date of first comparison period
//	$4: period2_start - Start date of second comparison period
//	$5: period2_end - End date of second comparison period
//
// Returns:
//
//	year: Year as text (e.g., '2023')
//	month: 3-letter month abbreviation (e.g., 'Jan')
//	total_success: Count of successful topups
//	total_amount: Sum of successful topup amounts
//
// Business Logic:
//   - Only includes successful topups (status = 'success')
//   - Covers two customizable time periods for comparison
//   - Zero-fills months with no activity
//   - Formats output for consistent visualization
//   - Orders by year and month (newest first)
//   - Useful for identifying seasonal topup patterns
func (q *Queries) GetMonthTopupStatusSuccessCardNumber(ctx context.Context, arg GetMonthTopupStatusSuccessCardNumberParams) ([]*GetMonthTopupStatusSuccessCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthTopupStatusSuccessCardNumber,
		arg.CardNumber,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthTopupStatusSuccessCardNumberRow
	for rows.Next() {
		var i GetMonthTopupStatusSuccessCardNumberRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalSuccess,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTopupAmounts = `-- name: GetMonthlyTopupAmounts :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.topup_amount), 0)::int AS total_amount
FROM
    months m
LEFT JOIN
    topups t ON EXTRACT(MONTH FROM t.topup_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.topup_time) = EXTRACT(YEAR FROM m.month)
    AND t.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyTopupAmountsRow struct {
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthlyTopupAmounts: Retrieves total topup amounts per month for the selected year
// Purpose: Visualize total topup volume across months in a given year
// Parameters:
//
//	$1: reference_date - Any date within the target year
//
// Returns:
//
//	month: 3-letter month abbreviation
//	total_amount: Sum of all topup amounts per month
//
// Business Logic:
//   - Filters soft-deleted entries (deleted_at IS NULL)
//   - Uses LEFT JOIN to ensure months with no topups are still included with amount = 0
//   - Useful for monthly topup charts or dashboards
func (q *Queries) GetMonthlyTopupAmounts(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyTopupAmountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTopupAmounts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTopupAmountsRow
	for rows.Next() {
		var i GetMonthlyTopupAmountsRow
		if err := rows.Scan(&i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTopupAmountsByCardNumber = `-- name: GetMonthlyTopupAmountsByCardNumber :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $2::timestamp),
        date_trunc('year', $2::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.topup_amount), 0)::int AS total_amount
FROM
    months m
LEFT JOIN
    topups t ON EXTRACT(MONTH FROM t.topup_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.topup_time) = EXTRACT(YEAR FROM m.month)
    AND t.card_number = $1
    AND t.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyTopupAmountsByCardNumberParams struct {
	CardNumber string    `json:"card_number"`
	Column2    time.Time `json:"column_2"`
}

type GetMonthlyTopupAmountsByCardNumberRow struct {
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthlyTopupAmountsByCardNumber: Retrieves total topup amounts per month for the selected year
// Purpose: Visualize total topup volume across months in a given year
// Parameters:
//
//	$1: card_number  - filter by card_number
//	$2: reference_date - Any date within the target year
//
// Returns:
//
//	month: 3-letter month abbreviation
//	total_amount: Sum of all topup amounts per month
//
// Business Logic:
//   - Filters soft-deleted entries (deleted_at IS NULL)
//   - Uses LEFT JOIN to ensure months with no topups are still included with amount = 0
//   - Useful for monthly topup charts or dashboards
func (q *Queries) GetMonthlyTopupAmountsByCardNumber(ctx context.Context, arg GetMonthlyTopupAmountsByCardNumberParams) ([]*GetMonthlyTopupAmountsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTopupAmountsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTopupAmountsByCardNumberRow
	for rows.Next() {
		var i GetMonthlyTopupAmountsByCardNumberRow
		if err := rows.Scan(&i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTopupMethods = `-- name: GetMonthlyTopupMethods :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
),
topup_methods AS (
    SELECT DISTINCT topup_method
    FROM topups
    WHERE deleted_at IS NULL
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    tm.topup_method,
    COALESCE(COUNT(t.topup_id), 0)::int AS total_topups,
    COALESCE(SUM(t.topup_amount), 0)::int AS total_amount
FROM
    months m
CROSS JOIN
    topup_methods tm
LEFT JOIN
    topups t ON EXTRACT(MONTH FROM t.topup_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.created_at) = EXTRACT(YEAR FROM m.month)
    AND t.topup_method = tm.topup_method
    AND t.deleted_at IS NULL
GROUP BY
    m.month,
    tm.topup_method
ORDER BY
    m.month,
    tm.topup_method
`

type GetMonthlyTopupMethodsRow struct {
	Month       string `json:"month"`
	TopupMethod string `json:"topup_method"`
	TotalTopups int32  `json:"total_topups"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthlyTopupMethods: Retrieves monthly breakdown of topup usage by method
// Purpose: Track topup method distribution and amounts over each month of the selected year
// Parameters:
//
//	$1: reference_date - Any date within the target year (used to define monthly range)
//
// Returns:
//
//	month: 3-letter month abbreviation (e.g., 'Jan')
//	topup_method: Method used for topup (e.g., 'bank_transfer', 'e-wallet')
//	total_topups: Count of topups using the method in that month
//	total_amount: Sum of topup amounts using the method in that month
//
// Business Logic:
//   - Ensures every topup method is shown for every month (even with 0 data)
//   - Filters out soft-deleted records (deleted_at IS NULL)
//   - Uses CROSS JOIN to combine months with all available methods
//   - Useful for visualizing adoption trends of each topup method monthly
func (q *Queries) GetMonthlyTopupMethods(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyTopupMethodsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTopupMethods, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTopupMethodsRow
	for rows.Next() {
		var i GetMonthlyTopupMethodsRow
		if err := rows.Scan(
			&i.Month,
			&i.TopupMethod,
			&i.TotalTopups,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTopupMethodsByCardNumber = `-- name: GetMonthlyTopupMethodsByCardNumber :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $2::timestamp),
        date_trunc('year', $2::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
),
topup_methods AS (
    SELECT DISTINCT topup_method
    FROM topups
    WHERE deleted_at IS NULL
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    tm.topup_method,
    COALESCE(COUNT(t.topup_id), 0)::int AS total_topups,
    COALESCE(SUM(t.topup_amount), 0)::int AS total_amount
FROM
    months m
CROSS JOIN
    topup_methods tm
LEFT JOIN
    topups t ON EXTRACT(MONTH FROM t.topup_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.topup_time) = EXTRACT(YEAR FROM m.month)
    AND t.topup_method = tm.topup_method
    AND t.card_number = $1
    AND t.deleted_at IS NULL
GROUP BY
    m.month,
    tm.topup_method
ORDER BY
    m.month,
    tm.topup_method
`

type GetMonthlyTopupMethodsByCardNumberParams struct {
	CardNumber string    `json:"card_number"`
	Column2    time.Time `json:"column_2"`
}

type GetMonthlyTopupMethodsByCardNumberRow struct {
	Month       string `json:"month"`
	TopupMethod string `json:"topup_method"`
	TotalTopups int32  `json:"total_topups"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthlyTopupMethodsByCardNumber: Retrieves monthly breakdown of topup usage by method
// Purpose: Track topup method distribution and amounts over each month of the selected year
// Parameters:
//
//	$1: card_number  - filter by card_number
//	$2: reference_date - Any date within the target year (used to define monthly range)
//
// Returns:
//
//	month: 3-letter month abbreviation (e.g., 'Jan')
//	topup_method: Method used for topup (e.g., 'bank_transfer', 'e-wallet')
//	total_topups: Count of topups using the method in that month
//	total_amount: Sum of topup amounts using the method in that month
//
// Business Logic:
//   - Ensures every topup method is shown for every month (even with 0 data)
//   - Filters out soft-deleted records (deleted_at IS NULL)
//   - Uses CROSS JOIN to combine months with all available methods
//   - Useful for visualizing adoption trends of each topup method monthly
func (q *Queries) GetMonthlyTopupMethodsByCardNumber(ctx context.Context, arg GetMonthlyTopupMethodsByCardNumberParams) ([]*GetMonthlyTopupMethodsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTopupMethodsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTopupMethodsByCardNumberRow
	for rows.Next() {
		var i GetMonthlyTopupMethodsByCardNumberRow
		if err := rows.Scan(
			&i.Month,
			&i.TopupMethod,
			&i.TotalTopups,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopupByID = `-- name: GetTopupByID :one
SELECT topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at FROM topups WHERE topup_id = $1 AND deleted_at IS NULL
`

// GetTopupByID: Retrieves a specific topup by ID
// Purpose: Used to display details of a single topup transaction
// Parameters:
//
//	$1: topup_id - Unique identifier of the topup
//
// Returns:
//
//	Topup record matching the ID (if not soft-deleted)
//
// Business Logic:
//   - Only returns record if it is active (deleted_at IS NULL)
func (q *Queries) GetTopupByID(ctx context.Context, topupID int32) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, getTopupByID, topupID)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTopups = `-- name: GetTopups :many
SELECT
    topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    topups
WHERE
    deleted_at IS NULL
    AND (
        $1::TEXT IS NULL
        OR card_number ILIKE '%' || $1 || '%'
        OR topup_no::TEXT ILIKE '%' || $1 || '%'
        OR topup_method ILIKE '%' || $1 || '%'
        OR status ILIKE '%' || $1 || '%'
    )
ORDER BY
    topup_time DESC
LIMIT $2 OFFSET $3
`

type GetTopupsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTopupsRow struct {
	TopupID     int32        `json:"topup_id"`
	TopupNo     uuid.UUID    `json:"topup_no"`
	CardNumber  string       `json:"card_number"`
	TopupAmount int32        `json:"topup_amount"`
	TopupMethod string       `json:"topup_method"`
	TopupTime   time.Time    `json:"topup_time"`
	Status      string       `json:"status"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// GetTopups: Retrieves paginated list of active topups with search capability
// Purpose: Provide admin or user access to topup history with search support
// Parameters:
//
//	$1: search_term - Optional filter to match card_number, topup_no, topup_method, or status (NULL for no filter)
//	$2: limit - Max number of records to return
//	$3: offset - Records to skip for pagination
//
// Returns:
//
//	All topup fields and total_count of matching records
//
// Business Logic:
//   - Filters out soft-deleted topups (deleted_at IS NULL)
//   - Supports partial, case-insensitive search across multiple fields
//   - Results sorted by topup_time (most recent first)
//   - total_count is used for frontend pagination
func (q *Queries) GetTopups(ctx context.Context, arg GetTopupsParams) ([]*GetTopupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopups, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTopupsRow
	for rows.Next() {
		var i GetTopupsRow
		if err := rows.Scan(
			&i.TopupID,
			&i.TopupNo,
			&i.CardNumber,
			&i.TopupAmount,
			&i.TopupMethod,
			&i.TopupTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopupsByCardNumber = `-- name: GetTopupsByCardNumber :many
SELECT
    topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    topups
WHERE
    deleted_at IS NULL
    AND card_number = $1 -- Filter by card_number
    AND (
        $2::TEXT IS NULL
        OR topup_no::TEXT ILIKE '%' || $2 || '%'
        OR topup_method ILIKE '%' || $2 || '%'
        OR status ILIKE '%' || $2 || '%'
    )
ORDER BY
    topup_time DESC
LIMIT $3 OFFSET $4
`

type GetTopupsByCardNumberParams struct {
	CardNumber string `json:"card_number"`
	Column2    string `json:"column_2"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type GetTopupsByCardNumberRow struct {
	TopupID     int32        `json:"topup_id"`
	TopupNo     uuid.UUID    `json:"topup_no"`
	CardNumber  string       `json:"card_number"`
	TopupAmount int32        `json:"topup_amount"`
	TopupMethod string       `json:"topup_method"`
	TopupTime   time.Time    `json:"topup_time"`
	Status      string       `json:"status"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// GetTopupsByCardNumber: Retrieves paginated topups based on card number and optional search keyword
// Purpose: View all topups for a specific card, with filtering and pagination
// Parameters:
//
//	$1: card_number - Exact card number match
//	$2: keyword - Optional keyword (nullable), filters topup_no, method, status
//	$3: limit - Number of records to return
//	$4: offset - Offset for pagination
//
// Returns:
//
//	All matching topup records with total_count using window function
//
// Business Logic:
//   - Skips soft-deleted records
//   - Ordered by topup_time descending
func (q *Queries) GetTopupsByCardNumber(ctx context.Context, arg GetTopupsByCardNumberParams) ([]*GetTopupsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopupsByCardNumber,
		arg.CardNumber,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTopupsByCardNumberRow
	for rows.Next() {
		var i GetTopupsByCardNumberRow
		if err := rows.Scan(
			&i.TopupID,
			&i.TopupNo,
			&i.CardNumber,
			&i.TopupAmount,
			&i.TopupMethod,
			&i.TopupTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedTopupByID = `-- name: GetTrashedTopupByID :one
SELECT topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at
FROM topups
WHERE
    topup_id = $1
    AND deleted_at IS NOT NULL
`

// GetTrashedTopupByID: Retrieves a topup that has been soft-deleted
// Purpose: Preview or manage trashed entries (e.g., for restore)
// Parameters:
//
//	$1: topup_id - ID of the soft-deleted topup
//
// Returns:
//
//	Full topup record if found and deleted_at IS NOT NULL
func (q *Queries) GetTrashedTopupByID(ctx context.Context, topupID int32) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, getTrashedTopupByID, topupID)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedTopups = `-- name: GetTrashedTopups :many
SELECT
    topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    topups
WHERE
    deleted_at IS NOT NULL
    AND (
        $1::TEXT IS NULL
        OR card_number ILIKE '%' || $1 || '%'
        OR topup_no::TEXT ILIKE '%' || $1 || '%'
        OR topup_method ILIKE '%' || $1 || '%'
    )
ORDER BY
    topup_time DESC
LIMIT $2 OFFSET $3
`

type GetTrashedTopupsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedTopupsRow struct {
	TopupID     int32        `json:"topup_id"`
	TopupNo     uuid.UUID    `json:"topup_no"`
	CardNumber  string       `json:"card_number"`
	TopupAmount int32        `json:"topup_amount"`
	TopupMethod string       `json:"topup_method"`
	TopupTime   time.Time    `json:"topup_time"`
	Status      string       `json:"status"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// GetTrashedTopups: Retrieves trashed (soft-deleted) topups with pagination and search
// Purpose: Allow recovery or permanent deletion of topups
// Parameters:
//
//	$1: search_term - Optional filter to match card_number, topup_no, or topup_method
//	$2: limit - Max records to return
//	$3: offset - Rows to skip
//
// Returns:
//
//	Trashed topup records with total_count
//
// Business Logic:
//   - Only includes topups where deleted_at IS NOT NULL
//   - Supports flexible search
//   - Results sorted by topup_time descending
func (q *Queries) GetTrashedTopups(ctx context.Context, arg GetTrashedTopupsParams) ([]*GetTrashedTopupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedTopups, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedTopupsRow
	for rows.Next() {
		var i GetTrashedTopupsRow
		if err := rows.Scan(
			&i.TopupID,
			&i.TopupNo,
			&i.CardNumber,
			&i.TopupAmount,
			&i.TopupMethod,
			&i.TopupTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupAmounts = `-- name: GetYearlyTopupAmounts :many
SELECT
    EXTRACT(YEAR FROM t.topup_time) AS year,
    SUM(t.topup_amount) AS total_amount
FROM
    topups t
WHERE
    t.deleted_at IS NULL
    AND EXTRACT(YEAR FROM t.topup_time) >= $1 - 4
    AND EXTRACT(YEAR FROM t.topup_time) <= $1
GROUP BY
    EXTRACT(YEAR FROM t.topup_time)
ORDER BY
    year
`

type GetYearlyTopupAmountsRow struct {
	Year        string `json:"year"`
	TotalAmount int64  `json:"total_amount"`
}

// GetYearlyTopupAmounts: Retrieves yearly total of topup amounts
// Purpose: Analyze yearly growth or decline in topup volume
// Parameters:
//
//	$1: current_year - The latest year to include (e.g., 2024), includes 5-year span (current_year - 4)
//
// Returns:
//
//	year: Year extracted from topup_time
//	total_amount: Sum of all topup amounts in the year
//
// Business Logic:
//   - Includes topup data from current year and 4 years prior
//   - Excludes soft-deleted records (deleted_at IS NULL)
//   - Ideal for trend lines or comparative bar charts by year
func (q *Queries) GetYearlyTopupAmounts(ctx context.Context, dollar_1 interface{}) ([]*GetYearlyTopupAmountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupAmounts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupAmountsRow
	for rows.Next() {
		var i GetYearlyTopupAmountsRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupAmountsByCardNumber = `-- name: GetYearlyTopupAmountsByCardNumber :many
SELECT
    EXTRACT(YEAR FROM t.topup_time) AS year,
    SUM(t.topup_amount) AS total_amount
FROM
    topups t
WHERE
    t.deleted_at IS NULL
    AND t.card_number = $1
    AND EXTRACT(YEAR FROM t.created_at) >= $2 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $2
GROUP BY
    EXTRACT(YEAR FROM t.topup_time)
ORDER BY
    year
`

type GetYearlyTopupAmountsByCardNumberParams struct {
	CardNumber string      `json:"card_number"`
	Column2    interface{} `json:"column_2"`
}

type GetYearlyTopupAmountsByCardNumberRow struct {
	Year        string `json:"year"`
	TotalAmount int64  `json:"total_amount"`
}

// GetYearlyTopupAmountsByCardNumber: Retrieves yearly total of topup amounts
// Purpose: Analyze yearly growth or decline in topup volume
// Parameters:
//
//	$1: card_number  - filter by card_number
//	$2: current_year - The latest year to include (e.g., 2024), includes 5-year span (current_year - 4)
//
// Returns:
//
//	year: Year extracted from topup_time
//	total_amount: Sum of all topup amounts in the year
//
// Business Logic:
//   - Includes topup data from current year and 4 years prior
//   - Excludes soft-deleted records (deleted_at IS NULL)
//   - Ideal for trend lines or comparative bar charts by year
func (q *Queries) GetYearlyTopupAmountsByCardNumber(ctx context.Context, arg GetYearlyTopupAmountsByCardNumberParams) ([]*GetYearlyTopupAmountsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupAmountsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupAmountsByCardNumberRow
	for rows.Next() {
		var i GetYearlyTopupAmountsByCardNumberRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupMethods = `-- name: GetYearlyTopupMethods :many
SELECT
    EXTRACT(YEAR FROM t.created_at) AS year,
    t.topup_method,
    COUNT(t.topup_id) AS total_topups,
    SUM(t.topup_amount) AS total_amount
FROM
    topups t
WHERE
    t.deleted_at IS NULL
    AND EXTRACT(YEAR FROM t.topup_time) >= $1 - 4
    AND EXTRACT(YEAR FROM t.topup_time) <= $1
GROUP BY
    EXTRACT(YEAR FROM t.created_at),
    t.topup_method
ORDER BY
    year
`

type GetYearlyTopupMethodsRow struct {
	Year        string `json:"year"`
	TopupMethod string `json:"topup_method"`
	TotalTopups int64  `json:"total_topups"`
	TotalAmount int64  `json:"total_amount"`
}

// GetYearlyTopupMethods: Retrieves yearly breakdown of topup usage by method
// Purpose: Analyze how different topup methods perform over the past 5 years
// Parameters:
//
//	$1: current_year - The final year to include (e.g., 2024), includes 5-year span (current_year - 4)
//
// Returns:
//
//	year: Year extracted from topup_time
//	topup_method: Method used for topup
//	total_topups: Number of topups using that method in the year
//	total_amount: Total topup amount for the method in the year
//
// Business Logic:
//   - Filters to topups within a 5-year window up to the given year
//   - Filters out soft-deleted data (deleted_at IS NULL)
//   - Useful for detecting long-term trends across payment methods
func (q *Queries) GetYearlyTopupMethods(ctx context.Context, dollar_1 interface{}) ([]*GetYearlyTopupMethodsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupMethods, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupMethodsRow
	for rows.Next() {
		var i GetYearlyTopupMethodsRow
		if err := rows.Scan(
			&i.Year,
			&i.TopupMethod,
			&i.TotalTopups,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupMethodsByCardNumber = `-- name: GetYearlyTopupMethodsByCardNumber :many
SELECT
    EXTRACT(YEAR FROM t.topup_time) AS year,
    t.topup_method,
    COUNT(t.topup_id) AS total_topups,
    SUM(t.topup_amount) AS total_amount
FROM
    topups t
WHERE
    t.deleted_at IS NULL
    AND t.card_number = $1
    AND EXTRACT(YEAR FROM t.created_at) >= $2 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $2
GROUP BY
    EXTRACT(YEAR FROM t.topup_time),
    t.topup_method
ORDER BY
    year
`

type GetYearlyTopupMethodsByCardNumberParams struct {
	CardNumber string      `json:"card_number"`
	Column2    interface{} `json:"column_2"`
}

type GetYearlyTopupMethodsByCardNumberRow struct {
	Year        string `json:"year"`
	TopupMethod string `json:"topup_method"`
	TotalTopups int64  `json:"total_topups"`
	TotalAmount int64  `json:"total_amount"`
}

// GetYearlyTopupMethodsByCardNumber: Retrieves yearly breakdown of topup usage by method
// Purpose: Analyze how different topup methods perform over the past 5 years
// Parameters:
//
//	$1: card_number  - filter by card_number
//	$2: current_year - The final year to include (e.g., 2024), includes 5-year span (current_year - 4)
//
// Returns:
//
//	year: Year extracted from topup_time
//	topup_method: Method used for topup
//	total_topups: Number of topups using that method in the year
//	total_amount: Total topup amount for the method in the year
//
// Business Logic:
//   - Filters to topups within a 5-year window up to the given year
//   - Filters out soft-deleted data (deleted_at IS NULL)
//   - Useful for detecting long-term trends across payment methods
func (q *Queries) GetYearlyTopupMethodsByCardNumber(ctx context.Context, arg GetYearlyTopupMethodsByCardNumberParams) ([]*GetYearlyTopupMethodsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupMethodsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupMethodsByCardNumberRow
	for rows.Next() {
		var i GetYearlyTopupMethodsByCardNumberRow
		if err := rows.Scan(
			&i.Year,
			&i.TopupMethod,
			&i.TotalTopups,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupStatusFailed = `-- name: GetYearlyTopupStatusFailed :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'failed'
        AND (
            EXTRACT(YEAR FROM t.topup_time) = $1::integer
            OR EXTRACT(YEAR FROM t.topup_time) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        total_failed::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTopupStatusFailedRow struct {
	Year        string `json:"year"`
	TotalFailed int32  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

// GetYearlyTopupStatusFailed: Retrieves yearly failed metrics for topups
// Purpose: Compare annual failedful topup performance
// Parameters:
//
//	$1: current_year - The target year (includes this year and previous)
//
// Returns:
//
//	year: Year as text (e.g., '2023')
//	total_failed: Count of failedful topups
//	total_amount: Sum of failedful topup amounts
//
// Business Logic:
//   - Only includes failedful topups (status = 'failed')
//   - Compares current year with previous year
//   - Zero-fills years with no activity
//   - Orders by year (newest first)
//   - Useful for year-over-year growth analysis
func (q *Queries) GetYearlyTopupStatusFailed(ctx context.Context, dollar_1 int32) ([]*GetYearlyTopupStatusFailedRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupStatusFailed, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupStatusFailedRow
	for rows.Next() {
		var i GetYearlyTopupStatusFailedRow
		if err := rows.Scan(&i.Year, &i.TotalFailed, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupStatusFailedCardNumber = `-- name: GetYearlyTopupStatusFailedCardNumber :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'failed'
        AND t.card_number = $1
            AND (
                EXTRACT(YEAR FROM t.topup_time) = $2::integer
                OR EXTRACT(YEAR FROM t.topup_time) = $2::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        total_failed::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $2::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $2::integer
    )

    UNION ALL

    SELECT
        ($2::integer - 1)::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $2::integer - 1
    )
)
SELECT year, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTopupStatusFailedCardNumberParams struct {
	CardNumber string `json:"card_number"`
	Column2    int32  `json:"column_2"`
}

type GetYearlyTopupStatusFailedCardNumberRow struct {
	Year        string `json:"year"`
	TotalFailed int32  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

// GetYearlyTopupStatusFailedCardNumber: Retrieves yearly failed metrics for topups
// Purpose: Compare annual failedful topup performance
// Parameters:
//
//	$1: card_number  - filter by card_number
//	$2: current_year - The target year (includes this year and previous)
//
// Returns:
//
//	year: Year as text (e.g., '2023')
//	total_failed: Count of failedful topups
//	total_amount: Sum of failedful topup amounts
//
// Business Logic:
//   - Only includes failedful topups (status = 'failed')
//   - Compares current year with previous year
//   - Zero-fills years with no activity
//   - Orders by year (newest first)
//   - Useful for year-over-year growth analysis
func (q *Queries) GetYearlyTopupStatusFailedCardNumber(ctx context.Context, arg GetYearlyTopupStatusFailedCardNumberParams) ([]*GetYearlyTopupStatusFailedCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupStatusFailedCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupStatusFailedCardNumberRow
	for rows.Next() {
		var i GetYearlyTopupStatusFailedCardNumberRow
		if err := rows.Scan(&i.Year, &i.TotalFailed, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupStatusSuccess = `-- name: GetYearlyTopupStatusSuccess :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'success'
        AND (
            EXTRACT(YEAR FROM t.topup_time) = $1::integer
            OR EXTRACT(YEAR FROM t.topup_time) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        total_success::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTopupStatusSuccessRow struct {
	Year         string `json:"year"`
	TotalSuccess int32  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

// GetYearlyTopupStatusSuccess: Retrieves yearly success metrics for topups
// Purpose: Compare annual successful topup performance
// Parameters:
//
//	$1: current_year - The target year (includes this year and previous)
//
// Returns:
//
//	year: Year as text (e.g., '2023')
//	total_success: Count of successful topups
//	total_amount: Sum of successful topup amounts
//
// Business Logic:
//   - Only includes successful topups (status = 'success')
//   - Compares current year with previous year
//   - Zero-fills years with no activity
//   - Orders by year (newest first)
//   - Useful for year-over-year growth analysis
func (q *Queries) GetYearlyTopupStatusSuccess(ctx context.Context, dollar_1 int32) ([]*GetYearlyTopupStatusSuccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupStatusSuccess, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupStatusSuccessRow
	for rows.Next() {
		var i GetYearlyTopupStatusSuccessRow
		if err := rows.Scan(&i.Year, &i.TotalSuccess, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupStatusSuccessCardNumber = `-- name: GetYearlyTopupStatusSuccessCardNumber :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'success'
        AND t.card_number = $1
            AND (
                EXTRACT(YEAR FROM t.topup_time) = $2::integer
                OR EXTRACT(YEAR FROM t.topup_time) = $2::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        total_success::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $2::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $2::integer
    )

    UNION ALL

    SELECT
        ($2::integer - 1)::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $2::integer - 1
    )
)
SELECT year, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTopupStatusSuccessCardNumberParams struct {
	CardNumber string `json:"card_number"`
	Column2    int32  `json:"column_2"`
}

type GetYearlyTopupStatusSuccessCardNumberRow struct {
	Year         string `json:"year"`
	TotalSuccess int32  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

// GetYearlyTopupStatusSuccess: Retrieves yearly success metrics for topups
// Purpose: Compare annual successful topup performance
// Parameters:
//
//	$1: card_number       - Optional filter by card_number (NULL to ignore filter)
//	$2: current_year - The target year (includes this year and previous)
//
// Returns:
//
//	year: Year as text (e.g., '2023')
//	total_success: Count of successful topups
//	total_amount: Sum of successful topup amounts
//
// Business Logic:
//   - Only includes successful topups (status = 'success')
//   - Compares current year with previous year
//   - Zero-fills years with no activity
//   - Orders by year (newest first)
//   - Useful for year-over-year growth analysis
func (q *Queries) GetYearlyTopupStatusSuccessCardNumber(ctx context.Context, arg GetYearlyTopupStatusSuccessCardNumberParams) ([]*GetYearlyTopupStatusSuccessCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupStatusSuccessCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupStatusSuccessCardNumberRow
	for rows.Next() {
		var i GetYearlyTopupStatusSuccessCardNumberRow
		if err := rows.Scan(&i.Year, &i.TotalSuccess, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllTopups = `-- name: RestoreAllTopups :exec
UPDATE topups
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// RestoreAllTopups: Restores all soft-deleted topups in bulk
// Purpose: Batch recovery of trashed topup data
// Business Logic:
//   - Sets deleted_at to NULL for all where it was not null
func (q *Queries) RestoreAllTopups(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllTopups)
	return err
}

const restoreTopup = `-- name: RestoreTopup :one
UPDATE topups
SET
    deleted_at = NULL
WHERE
    topup_id = $1
    AND deleted_at IS NOT NULL
RETURNING topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at
`

// RestoreTopup: Restores a soft-deleted topup by nullifying deleted_at
// Purpose: Reactivate a previously trashed topup
// Parameters:
//
//	$1: topup_id - ID of the topup to restore
//
// Business Logic:
//   - Only applies to records where deleted_at IS NOT NULL
func (q *Queries) RestoreTopup(ctx context.Context, topupID int32) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, restoreTopup, topupID)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashTopup = `-- name: TrashTopup :one
UPDATE topups
SET
    deleted_at = current_timestamp
WHERE
    topup_id = $1
    AND deleted_at IS NULL
RETURNING topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at
`

// TrashTopup: Soft deletes a topup by setting deleted_at
// Purpose: Moves topup to trash without losing data
// Parameters:
//
//	$1: topup_id - ID of the topup to soft-delete
//
// Business Logic:
//   - Only active (non-deleted) records can be trashed
//   - Allows restore in future
func (q *Queries) TrashTopup(ctx context.Context, topupID int32) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, trashTopup, topupID)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateTopup = `-- name: UpdateTopup :one
UPDATE topups
SET
    card_number = $2,
    topup_amount = $3,
    topup_method = $4,
    topup_time = $5,
    updated_at = current_timestamp
WHERE
    topup_id = $1
    AND deleted_at IS NULL
RETURNING topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at
`

type UpdateTopupParams struct {
	TopupID     int32     `json:"topup_id"`
	CardNumber  string    `json:"card_number"`
	TopupAmount int32     `json:"topup_amount"`
	TopupMethod string    `json:"topup_method"`
	TopupTime   time.Time `json:"topup_time"`
}

// UpdateTopup: Updates an existing topup transaction
// Purpose: Modify existing topup information by ID
// Parameters:
//
//	$1: topup_id - ID of the topup to update
//	$2: card_number - Updated card number
//	$3: topup_amount - Updated amount
//	$4: topup_method - Updated payment method
//	$5: topup_time - Updated transaction time
//
// Business Logic:
//   - Skips soft-deleted records (deleted_at IS NULL)
//   - Updates updated_at automatically
func (q *Queries) UpdateTopup(ctx context.Context, arg UpdateTopupParams) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, updateTopup,
		arg.TopupID,
		arg.CardNumber,
		arg.TopupAmount,
		arg.TopupMethod,
		arg.TopupTime,
	)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateTopupAmount = `-- name: UpdateTopupAmount :one
UPDATE topups
SET
    topup_amount = $2,
    updated_at = current_timestamp
WHERE
    topup_id = $1
    AND deleted_at IS NULL
RETURNING topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at
`

type UpdateTopupAmountParams struct {
	TopupID     int32 `json:"topup_id"`
	TopupAmount int32 `json:"topup_amount"`
}

// UpdateTopupAmount: Updates only the topup_amount field for a specific topup
// Purpose: Allow adjustment of topup amount without affecting other fields
// Parameters:
//
//	$1: topup_id - ID of the target topup
//	$2: new topup amount
//
// Business Logic:
//   - Ignores deleted entries
//   - Automatically updates the updated_at timestamp
func (q *Queries) UpdateTopupAmount(ctx context.Context, arg UpdateTopupAmountParams) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, updateTopupAmount, arg.TopupID, arg.TopupAmount)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateTopupStatus = `-- name: UpdateTopupStatus :one
UPDATE topups
SET
    status = $2,
    updated_at = current_timestamp
WHERE
    topup_id = $1
    AND deleted_at IS NULL
RETURNING topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at
`

type UpdateTopupStatusParams struct {
	TopupID int32  `json:"topup_id"`
	Status  string `json:"status"`
}

// UpdateTopupStatus: Updates the status of a specific topup
// Purpose: Mark topup as 'success', 'failed', etc.
// Parameters:
//
//	$1: topup_id - ID of the topup
//	$2: new status value (e.g., 'success', 'failed')
//
// Business Logic:
//   - Applies only to active (non-deleted) records
//   - updated_at is refreshed
func (q *Queries) UpdateTopupStatus(ctx context.Context, arg UpdateTopupStatusParams) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, updateTopupStatus, arg.TopupID, arg.Status)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
