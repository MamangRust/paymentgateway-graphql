// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: merchant.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createMerchant = `-- name: CreateMerchant :one
INSERT INTO
    merchants (
        name,
        api_key,
        user_id,
        status,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        current_timestamp,
        current_timestamp
    ) RETURNING merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at
`

type CreateMerchantParams struct {
	Name   string `json:"name"`
	ApiKey string `json:"api_key"`
	UserID int32  `json:"user_id"`
	Status string `json:"status"`
}

// Create Merchant
// Purpose: Insert a new merchant record into the database
// Parameters:
//
//	$1: name - The name of the merchant
//	$2: api_key - Unique API key for the merchant
//	$3: user_id - ID of the user associated with the merchant
//	$4: status - Current status of the merchant (e.g., active, inactive)
//
// Returns:
//   - The newly created merchant record
//
// Business Logic:
//   - Inserts a new merchant with the provided details.
//   - Sets the created_at and updated_at timestamps to the current time.
//   - Returns the created merchant's data using the RETURNING clause.
func (q *Queries) CreateMerchant(ctx context.Context, arg CreateMerchantParams) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, createMerchant,
		arg.Name,
		arg.ApiKey,
		arg.UserID,
		arg.Status,
	)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantNo,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentMerchants = `-- name: DeleteAllPermanentMerchants :exec
DELETE FROM merchants
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Merchants Permanently
// Purpose: Permanently delete all merchants that are soft deleted
// Business Logic:
//   - Permanently deletes all merchants that have been soft deleted (i.e., deleted_at is not NULL).
//   - Removes these merchants completely from the database.
func (q *Queries) DeleteAllPermanentMerchants(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentMerchants)
	return err
}

const deleteMerchantPermanently = `-- name: DeleteMerchantPermanently :exec
DELETE FROM merchants WHERE merchant_id = $1 AND deleted_at IS NOT NULL
`

// Delete Merchant Permanently
// Purpose: Permanently delete a merchant from the database
// Parameters:
//
//	$1: merchant_id - ID of the merchant to be permanently deleted
//
// Business Logic:
//   - Deletes the specified merchant from the database.
//   - Ensures the merchant is marked as deleted (deleted_at is not NULL).
func (q *Queries) DeleteMerchantPermanently(ctx context.Context, merchantID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMerchantPermanently, merchantID)
	return err
}

const findAllTransactions = `-- name: FindAllTransactions :many
SELECT
    t.transaction_id,
    t.card_number,
    t.amount,
    t.payment_method,
    t.merchant_id,
    m.name AS merchant_name,
    t.transaction_time,
    t.created_at,
    t.updated_at,
    t.deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transactions t
JOIN
    merchants m ON t.merchant_id = m.merchant_id
WHERE
    t.deleted_at IS NULL
    AND ($1::TEXT IS NULL OR t.card_number ILIKE '%' || $1 || '%' OR t.payment_method ILIKE '%' || $1 || '%')
ORDER BY
    t.transaction_time DESC
LIMIT $2 OFFSET $3
`

type FindAllTransactionsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type FindAllTransactionsRow struct {
	TransactionID   int32        `json:"transaction_id"`
	CardNumber      string       `json:"card_number"`
	Amount          int32        `json:"amount"`
	PaymentMethod   string       `json:"payment_method"`
	MerchantID      int32        `json:"merchant_id"`
	MerchantName    string       `json:"merchant_name"`
	TransactionTime time.Time    `json:"transaction_time"`
	CreatedAt       sql.NullTime `json:"created_at"`
	UpdatedAt       sql.NullTime `json:"updated_at"`
	DeletedAt       sql.NullTime `json:"deleted_at"`
	TotalCount      int64        `json:"total_count"`
}

// FindAllTransactions: Retrieves a paginated list of active transactions with optional search
// Purpose: Display transaction list with merchant info, filtered by card number or payment method
// Parameters:
//
//	$1: search_query (TEXT, nullable) - Optional search string to match card_number or payment_method
//	$2: limit (INTEGER) - Maximum number of records to return (pagination)
//	$3: offset (INTEGER) - Number of records to skip (pagination)
//
// Returns:
//   - transaction_id
//   - card_number
//   - amount
//   - payment_method
//   - merchant_id
//   - merchant_name (from join with merchants table)
//   - transaction_time
//   - created_at, updated_at, deleted_at (for audit purposes)
//   - total_count: Total number of records matching the filter (useful for pagination metadata)
//
// Business Logic:
//   - Joins `transactions` with `merchants` to retrieve merchant name
//   - Filters out soft-deleted transactions (where deleted_at IS NOT NULL)
//   - Applies case-insensitive partial match on card_number or payment_method if search query is provided
//   - Uses `COUNT(*) OVER()` to include total matching count for pagination without a separate query
//   - Results are ordered by `transaction_time` descending
func (q *Queries) FindAllTransactions(ctx context.Context, arg FindAllTransactionsParams) ([]*FindAllTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllTransactions, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAllTransactionsRow
	for rows.Next() {
		var i FindAllTransactionsRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.CardNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.MerchantID,
			&i.MerchantName,
			&i.TransactionTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllTransactionsByApikey = `-- name: FindAllTransactionsByApikey :many
SELECT
    t.transaction_id,
    t.card_number,
    t.amount,
    t.payment_method,
    t.merchant_id,
    m.name AS merchant_name,
    t.transaction_time,
    t.created_at,
    t.updated_at,
    t.deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transactions t
JOIN
    merchants m ON t.merchant_id = m.merchant_id
WHERE
    t.deleted_at IS NULL
    AND m.api_key = $1
    AND ($2::TEXT IS NULL OR t.card_number ILIKE '%' || $2 || '%' OR t.payment_method ILIKE '%' || $2 || '%')
ORDER BY
    t.transaction_time DESC
LIMIT $3 OFFSET $4
`

type FindAllTransactionsByApikeyParams struct {
	ApiKey  string `json:"api_key"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type FindAllTransactionsByApikeyRow struct {
	TransactionID   int32        `json:"transaction_id"`
	CardNumber      string       `json:"card_number"`
	Amount          int32        `json:"amount"`
	PaymentMethod   string       `json:"payment_method"`
	MerchantID      int32        `json:"merchant_id"`
	MerchantName    string       `json:"merchant_name"`
	TransactionTime time.Time    `json:"transaction_time"`
	CreatedAt       sql.NullTime `json:"created_at"`
	UpdatedAt       sql.NullTime `json:"updated_at"`
	DeletedAt       sql.NullTime `json:"deleted_at"`
	TotalCount      int64        `json:"total_count"`
}

// FindAllTransactions: Retrieves a paginated list of active transactions with optional search
// Purpose: Display transaction list with merchant info, filtered by card number or payment method
// Parameters:
//
//	$1: api-key - The merchant to filter transactions
//	$2: search_query (TEXT, nullable) - Optional search string to match card_number or payment_method
//	$3: limit (INTEGER) - Maximum number of records to return (pagination)
//	$4: offset (INTEGER) - Number of records to skip (pagination)
//
// Returns:
//   - transaction_id
//   - card_number
//   - amount
//   - payment_method
//   - merchant_id
//   - merchant_name (from join with merchants table)
//   - transaction_time
//   - created_at, updated_at, deleted_at (for audit purposes)
//   - total_count: Total number of records matching the filter (useful for pagination metadata)
//
// Business Logic:
//   - Joins `transactions` with `merchants` to retrieve merchant name
//   - Filters out soft-deleted transactions (where deleted_at IS NOT NULL)
//   - Applies case-insensitive partial match on card_number or payment_method if search query is provided
//   - Uses `COUNT(*) OVER()` to include total matching count for pagination without a separate query
//   - Results are ordered by `transaction_time` descending
func (q *Queries) FindAllTransactionsByApikey(ctx context.Context, arg FindAllTransactionsByApikeyParams) ([]*FindAllTransactionsByApikeyRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllTransactionsByApikey,
		arg.ApiKey,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAllTransactionsByApikeyRow
	for rows.Next() {
		var i FindAllTransactionsByApikeyRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.CardNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.MerchantID,
			&i.MerchantName,
			&i.TransactionTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllTransactionsByMerchant = `-- name: FindAllTransactionsByMerchant :many
SELECT
    t.transaction_id,
    t.card_number,
    t.amount,
    t.payment_method,
    t.merchant_id,
    m.name AS merchant_name,
    t.transaction_time,
    t.created_at,
    t.updated_at,
    t.deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transactions t
JOIN
    merchants m ON t.merchant_id = m.merchant_id
WHERE
    t.deleted_at IS NULL
    AND t.merchant_id = $1
    AND ($2::TEXT IS NULL OR t.card_number ILIKE '%' || $2 || '%' OR t.payment_method ILIKE '%' || $2 || '%')
ORDER BY
    t.transaction_time DESC
LIMIT $3 OFFSET $4
`

type FindAllTransactionsByMerchantParams struct {
	MerchantID int32  `json:"merchant_id"`
	Column2    string `json:"column_2"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type FindAllTransactionsByMerchantRow struct {
	TransactionID   int32        `json:"transaction_id"`
	CardNumber      string       `json:"card_number"`
	Amount          int32        `json:"amount"`
	PaymentMethod   string       `json:"payment_method"`
	MerchantID      int32        `json:"merchant_id"`
	MerchantName    string       `json:"merchant_name"`
	TransactionTime time.Time    `json:"transaction_time"`
	CreatedAt       sql.NullTime `json:"created_at"`
	UpdatedAt       sql.NullTime `json:"updated_at"`
	DeletedAt       sql.NullTime `json:"deleted_at"`
	TotalCount      int64        `json:"total_count"`
}

// FindAllTransactions: Retrieves a paginated list of active transactions with optional search
// Purpose: Display transaction list with merchant info, filtered by card number or payment method
// Parameters:
//
//	$1: merchant_id - The merchant to filter transactions
//	$2: search_query (TEXT, nullable) - Optional search string to match card_number or payment_method
//	$3: limit (INTEGER) - Maximum number of records to return (pagination)
//	$4: offset (INTEGER) - Number of records to skip (pagination)
//
// Returns:
//   - transaction_id
//   - card_number
//   - amount
//   - payment_method
//   - merchant_id
//   - merchant_name (from join with merchants table)
//   - transaction_time
//   - created_at, updated_at, deleted_at (for audit purposes)
//   - total_count: Total number of records matching the filter (useful for pagination metadata)
//
// Business Logic:
//   - Joins `transactions` with `merchants` to retrieve merchant name
//   - Filters out soft-deleted transactions (where deleted_at IS NOT NULL)
//   - Applies case-insensitive partial match on card_number or payment_method if search query is provided
//   - Uses `COUNT(*) OVER()` to include total matching count for pagination without a separate query
//   - Results are ordered by `transaction_time` descending
func (q *Queries) FindAllTransactionsByMerchant(ctx context.Context, arg FindAllTransactionsByMerchantParams) ([]*FindAllTransactionsByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllTransactionsByMerchant,
		arg.MerchantID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAllTransactionsByMerchantRow
	for rows.Next() {
		var i FindAllTransactionsByMerchantRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.CardNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.MerchantID,
			&i.MerchantName,
			&i.TransactionTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveMerchants = `-- name: GetActiveMerchants :many
SELECT
    merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM merchants
WHERE deleted_at IS NULL
    AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%' OR api_key ILIKE '%' || $1 || '%' OR status ILIKE '%' || $1 || '%')
ORDER BY merchant_id
LIMIT $2 OFFSET $3
`

type GetActiveMerchantsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveMerchantsRow struct {
	MerchantID int32        `json:"merchant_id"`
	MerchantNo uuid.UUID    `json:"merchant_no"`
	Name       string       `json:"name"`
	ApiKey     string       `json:"api_key"`
	UserID     int32        `json:"user_id"`
	Status     string       `json:"status"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// GetActiveMerchants: Retrieves paginated list of active merchants with search capability
// Purpose: List currently active merchants (same as GetMerchants)
// Parameters:
//
//	$1: search_term - Optional text to filter by name, api_key, or status (NULL for no filter)
//	$2: limit - Maximum number of records to return
//	$3: offset - Number of records to skip for pagination
//
// Returns:
//
//	All merchant fields plus total_count of matching records
//
// Business Logic:
//   - Excludes soft-deleted merchants (deleted_at IS NULL)
//   - Supports case-insensitive partial matching on name, api_key, and status
//   - Returns results ordered by merchant_id
//   - Provides total_count for pagination calculations
func (q *Queries) GetActiveMerchants(ctx context.Context, arg GetActiveMerchantsParams) ([]*GetActiveMerchantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveMerchants, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveMerchantsRow
	for rows.Next() {
		var i GetActiveMerchantsRow
		if err := rows.Scan(
			&i.MerchantID,
			&i.MerchantNo,
			&i.Name,
			&i.ApiKey,
			&i.UserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantByApiKey = `-- name: GetMerchantByApiKey :one
SELECT merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at FROM merchants WHERE api_key = $1 AND deleted_at IS NULL
`

// GetMerchantByApiKey: Retrieves a merchant by its API key
// Purpose: Authenticate or lookup a merchant using its API key
// Parameters:
//
//	$1: api_key - API key of the merchant
//
// Returns:
//
//	Complete merchant record
//
// Business Logic:
//   - Excludes soft-deleted merchants (deleted_at IS NULL)
func (q *Queries) GetMerchantByApiKey(ctx context.Context, apiKey string) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, getMerchantByApiKey, apiKey)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantNo,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getMerchantByID = `-- name: GetMerchantByID :one
SELECT merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at
FROM merchants
WHERE
    merchant_id = $1
    AND deleted_at IS NULL
`

// GetMerchantByID: Retrieves a merchant by its unique ID
// Purpose: Fetch details of a single merchant if not soft-deleted
// Parameters:
//
//	$1: merchant_id - Unique identifier of the merchant
//
// Returns:
//
//	Complete merchant record
//
// Business Logic:
//   - Excludes soft-deleted merchants (deleted_at IS NULL)
func (q *Queries) GetMerchantByID(ctx context.Context, merchantID int32) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, getMerchantByID, merchantID)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantNo,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getMerchantByName = `-- name: GetMerchantByName :one
SELECT merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at FROM merchants WHERE name = $1 AND deleted_at IS NULL
`

// GetMerchantByName: Retrieves a merchant by its name
// Purpose: Find merchant data based on exact name match
// Parameters:
//
//	$1: name - Exact name of the merchant
//
// Returns:
//
//	Complete merchant record
//
// Business Logic:
//   - Excludes soft-deleted merchants (deleted_at IS NULL)
func (q *Queries) GetMerchantByName(ctx context.Context, name string) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, getMerchantByName, name)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantNo,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getMerchants = `-- name: GetMerchants :many
SELECT
    merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM merchants
WHERE deleted_at IS NULL
    AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%' OR api_key ILIKE '%' || $1 || '%' OR status ILIKE '%' || $1 || '%')
ORDER BY merchant_id
LIMIT $2 OFFSET $3
`

type GetMerchantsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetMerchantsRow struct {
	MerchantID int32        `json:"merchant_id"`
	MerchantNo uuid.UUID    `json:"merchant_no"`
	Name       string       `json:"name"`
	ApiKey     string       `json:"api_key"`
	UserID     int32        `json:"user_id"`
	Status     string       `json:"status"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// GetMerchants: Retrieves paginated list of all non-deleted merchants with search capability
// Purpose: Display all active (non-trashed) merchants in admin interface
// Parameters:
//
//	$1: search_term - Optional text to filter by name, api_key, or status (NULL for no filter)
//	$2: limit - Maximum number of records to return
//	$3: offset - Number of records to skip for pagination
//
// Returns:
//
//	All merchant fields plus total_count of matching records
//
// Business Logic:
//   - Excludes soft-deleted merchants (deleted_at IS NULL)
//   - Supports partial text search on name, api_key, and status (case-insensitive)
//   - Returns results ordered by merchant_id
//   - Provides total_count for pagination calculations
func (q *Queries) GetMerchants(ctx context.Context, arg GetMerchantsParams) ([]*GetMerchantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMerchants, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMerchantsRow
	for rows.Next() {
		var i GetMerchantsRow
		if err := rows.Scan(
			&i.MerchantID,
			&i.MerchantNo,
			&i.Name,
			&i.ApiKey,
			&i.UserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantsByUserID = `-- name: GetMerchantsByUserID :many
SELECT merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at FROM merchants WHERE user_id = $1 AND deleted_at IS NULL
`

// GetMerchantsByUserID: Retrieves all merchants associated with a user
// Purpose: List all merchants that belong to a specific user
// Parameters:
//
//	$1: user_id - ID of the user who owns the merchants
//
// Returns:
//
//	List of merchant records
//
// Business Logic:
//   - Excludes soft-deleted merchants (deleted_at IS NULL)
func (q *Queries) GetMerchantsByUserID(ctx context.Context, userID int32) ([]*Merchant, error) {
	rows, err := q.db.QueryContext(ctx, getMerchantsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Merchant
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.MerchantID,
			&i.MerchantNo,
			&i.Name,
			&i.ApiKey,
			&i.UserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyAmountByApikey = `-- name: GetMonthlyAmountByApikey :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.amount), 0)::int AS total_amount
FROM
    months m
LEFT JOIN
    transactions t ON EXTRACT(MONTH FROM t.transaction_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM m.month)
    AND t.deleted_at IS NULL
LEFT JOIN
    merchants mch ON t.merchant_id = mch.merchant_id
    AND mch.deleted_at IS NULL
    AND mch.api_key = $2
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyAmountByApikeyParams struct {
	Column1 time.Time `json:"column_1"`
	ApiKey  string    `json:"api_key"`
}

type GetMonthlyAmountByApikeyRow struct {
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthlyAmountByApikey: Retrieves total transaction amount per month for a specific merchant and year
// Purpose: Generate monthly income report for a specific merchant regardless of payment method
// Parameters:
//
//	$1: reference_date - Any date within the target year
//	$2: api-key - The merchant to filter transactions
//
// Returns:
//   - Month name (e.g., Jan, Feb)
//   - Total transaction amount (0 if no activity)
//
// Business Logic:
//   - Generates complete 12-month series for the given year
//   - Filters only active (non-deleted) transactions and merchants
//   - Filters by specific merchant_id
//   - Uses LEFT JOIN to ensure each month is represented
//   - Uses COALESCE to return 0 if a month has no transaction data
//   - Results are ordered chronologically by month
func (q *Queries) GetMonthlyAmountByApikey(ctx context.Context, arg GetMonthlyAmountByApikeyParams) ([]*GetMonthlyAmountByApikeyRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyAmountByApikey, arg.Column1, arg.ApiKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyAmountByApikeyRow
	for rows.Next() {
		var i GetMonthlyAmountByApikeyRow
		if err := rows.Scan(&i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyAmountByMerchants = `-- name: GetMonthlyAmountByMerchants :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.amount), 0)::int AS total_amount
FROM
    months m
LEFT JOIN
    transactions t ON EXTRACT(MONTH FROM t.transaction_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM m.month)
    AND t.deleted_at IS NULL
    AND t.merchant_id = $2
LEFT JOIN
    merchants mch ON t.merchant_id = mch.merchant_id
    AND mch.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyAmountByMerchantsParams struct {
	Column1    time.Time `json:"column_1"`
	MerchantID int32     `json:"merchant_id"`
}

type GetMonthlyAmountByMerchantsRow struct {
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthlyAmountByMerchants: Retrieves total transaction amount per month for a specific merchant and year
// Purpose: Generate monthly income report for a specific merchant regardless of payment method
// Parameters:
//
//	$1: reference_date - Any date within the target year
//	$2: merchant_id - The merchant to filter transactions
//
// Returns:
//   - Month name (e.g., Jan, Feb)
//   - Total transaction amount (0 if no activity)
//
// Business Logic:
//   - Generates complete 12-month series for the given year
//   - Filters only active (non-deleted) transactions and merchants
//   - Filters by specific merchant_id
//   - Uses LEFT JOIN to ensure each month is represented
//   - Uses COALESCE to return 0 if a month has no transaction data
//   - Results are ordered chronologically by month
func (q *Queries) GetMonthlyAmountByMerchants(ctx context.Context, arg GetMonthlyAmountByMerchantsParams) ([]*GetMonthlyAmountByMerchantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyAmountByMerchants, arg.Column1, arg.MerchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyAmountByMerchantsRow
	for rows.Next() {
		var i GetMonthlyAmountByMerchantsRow
		if err := rows.Scan(&i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyAmountMerchant = `-- name: GetMonthlyAmountMerchant :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.amount), 0)::int AS total_amount
FROM
    months m
LEFT JOIN
    transactions t ON EXTRACT(MONTH FROM t.transaction_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM m.month)
    AND t.deleted_at IS NULL
LEFT JOIN
    merchants mch ON t.merchant_id = mch.merchant_id
    AND mch.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyAmountMerchantRow struct {
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthlyAmountMerchant: Retrieves total transaction amount per month for a given year
// Purpose: Generate monthly income report regardless of payment method
// Parameters:
//
//	$1: reference_date - Any date within the target year
//
// Returns:
//   - Month name (e.g., Jan, Feb)
//   - Total transaction amount (0 if no activity)
//
// Business Logic:
//   - Generates complete 12-month series
//   - Includes only active (non-deleted) transactions and merchants
//   - Uses LEFT JOIN to ensure each month is represented
//   - Uses COALESCE to return 0 if a month has no data
//   - Ordered chronologically by month
func (q *Queries) GetMonthlyAmountMerchant(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyAmountMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyAmountMerchant, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyAmountMerchantRow
	for rows.Next() {
		var i GetMonthlyAmountMerchantRow
		if err := rows.Scan(&i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyPaymentMethodByApikey = `-- name: GetMonthlyPaymentMethodByApikey :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
),
payment_methods AS (
    SELECT DISTINCT payment_method
    FROM transactions
    WHERE deleted_at IS NULL
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    pm.payment_method,
    COALESCE(SUM(t.amount), 0)::int AS total_amount
FROM
    months m
CROSS JOIN
    payment_methods pm
LEFT JOIN
    transactions t ON EXTRACT(MONTH FROM t.transaction_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM m.month)
    AND t.payment_method = pm.payment_method
    AND t.deleted_at IS NULL
LEFT JOIN
    merchants mch ON t.merchant_id = mch.merchant_id
    AND mch.deleted_at IS NULL
    AND mch.api_key = $2
GROUP BY
    m.month,
    pm.payment_method
ORDER BY
    m.month,
    pm.payment_method
`

type GetMonthlyPaymentMethodByApikeyParams struct {
	Column1 time.Time `json:"column_1"`
	ApiKey  string    `json:"api_key"`
}

type GetMonthlyPaymentMethodByApikeyRow struct {
	Month         string `json:"month"`
	PaymentMethod string `json:"payment_method"`
	TotalAmount   int32  `json:"total_amount"`
}

// GetMonthlyPaymentMethodByApikey: Retrieves total transaction amount per payment method per month for a specific merchant
// Purpose: Analyze monthly transaction totals by payment method for a specific merchant and year
// Parameters:
//
//	$1: reference_date - Any date within the target year
//	$2: api-key - The merchant to filter transactions
//
// Returns:
//   - Month name (e.g., Jan, Feb)
//   - Payment method
//   - Total transaction amount for each combination
//
// Business Logic:
//   - Generates a complete 12-month series for the given year
//   - Filters only active (non-deleted) transactions and merchants
//   - Filters by specific merchant_id
//   - Uses LEFT JOIN and CROSS JOIN to ensure all months and payment methods are included
//   - Uses COALESCE to return 0 for combinations with no data
//   - Results are ordered chronologically by month
func (q *Queries) GetMonthlyPaymentMethodByApikey(ctx context.Context, arg GetMonthlyPaymentMethodByApikeyParams) ([]*GetMonthlyPaymentMethodByApikeyRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyPaymentMethodByApikey, arg.Column1, arg.ApiKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyPaymentMethodByApikeyRow
	for rows.Next() {
		var i GetMonthlyPaymentMethodByApikeyRow
		if err := rows.Scan(&i.Month, &i.PaymentMethod, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyPaymentMethodByMerchants = `-- name: GetMonthlyPaymentMethodByMerchants :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
),
payment_methods AS (
    SELECT DISTINCT payment_method
    FROM transactions
    WHERE deleted_at IS NULL
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    pm.payment_method,
    COALESCE(SUM(t.amount), 0)::int AS total_amount
FROM
    months m
CROSS JOIN
    payment_methods pm
LEFT JOIN
    transactions t ON EXTRACT(MONTH FROM t.transaction_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM m.month)
    AND t.payment_method = pm.payment_method
    AND t.deleted_at IS NULL
    AND t.merchant_id = $2
LEFT JOIN
    merchants mch ON t.merchant_id = mch.merchant_id
    AND mch.deleted_at IS NULL
GROUP BY
    m.month,
    pm.payment_method
ORDER BY
    m.month,
    pm.payment_method
`

type GetMonthlyPaymentMethodByMerchantsParams struct {
	Column1    time.Time `json:"column_1"`
	MerchantID int32     `json:"merchant_id"`
}

type GetMonthlyPaymentMethodByMerchantsRow struct {
	Month         string `json:"month"`
	PaymentMethod string `json:"payment_method"`
	TotalAmount   int32  `json:"total_amount"`
}

// GetMonthlyPaymentMethodByMerchants: Retrieves total transaction amount per payment method per month for a specific merchant
// Purpose: Analyze monthly transaction totals by payment method for a specific merchant and year
// Parameters:
//
//	$1: reference_date - Any date within the target year
//	$2: merchant_id - The merchant to filter transactions
//
// Returns:
//   - Month name (e.g., Jan, Feb)
//   - Payment method
//   - Total transaction amount for each combination
//
// Business Logic:
//   - Generates a complete 12-month series for the given year
//   - Filters only active (non-deleted) transactions and merchants
//   - Filters by specific merchant_id
//   - Uses LEFT JOIN and CROSS JOIN to ensure all months and payment methods are included
//   - Uses COALESCE to return 0 for combinations with no data
//   - Results are ordered chronologically by month
func (q *Queries) GetMonthlyPaymentMethodByMerchants(ctx context.Context, arg GetMonthlyPaymentMethodByMerchantsParams) ([]*GetMonthlyPaymentMethodByMerchantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyPaymentMethodByMerchants, arg.Column1, arg.MerchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyPaymentMethodByMerchantsRow
	for rows.Next() {
		var i GetMonthlyPaymentMethodByMerchantsRow
		if err := rows.Scan(&i.Month, &i.PaymentMethod, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyPaymentMethodsMerchant = `-- name: GetMonthlyPaymentMethodsMerchant :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
),
payment_methods AS (
    SELECT DISTINCT payment_method
    FROM transactions
    WHERE deleted_at IS NULL
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    pm.payment_method,
    COALESCE(SUM(t.amount), 0)::int AS total_amount
FROM
    months m
CROSS JOIN
    payment_methods pm
LEFT JOIN
    transactions t ON EXTRACT(MONTH FROM t.transaction_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM m.month)
    AND t.payment_method = pm.payment_method
    AND t.deleted_at IS NULL
LEFT JOIN
    merchants mch ON t.merchant_id = mch.merchant_id
    AND mch.deleted_at IS NULL
GROUP BY
    m.month,
    pm.payment_method
ORDER BY
    m.month,
    pm.payment_method
`

type GetMonthlyPaymentMethodsMerchantRow struct {
	Month         string `json:"month"`
	PaymentMethod string `json:"payment_method"`
	TotalAmount   int32  `json:"total_amount"`
}

// GetMonthlyPaymentMethodsMerchant: Retrieves monthly transaction totals per payment method
// Purpose: Analyze monthly transaction distribution across payment methods for a given year
// Parameters:
//
//	$1: reference_date - Any date within the target year
//
// Returns:
//   - Month name (e.g., Jan, Feb)
//   - Payment method
//   - Total transaction amount (0 if no activity)
//
// Business Logic:
//   - Generates complete 12-month series from the reference year
//   - Cross joins with distinct active payment methods
//   - Filters only active (non-deleted) transactions and merchants
//   - Uses LEFT JOIN to ensure all month-method combinations are included
//   - Uses COALESCE to display 0 for months with no transactions
//   - Ordered by month and payment method
func (q *Queries) GetMonthlyPaymentMethodsMerchant(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyPaymentMethodsMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyPaymentMethodsMerchant, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyPaymentMethodsMerchantRow
	for rows.Next() {
		var i GetMonthlyPaymentMethodsMerchantRow
		if err := rows.Scan(&i.Month, &i.PaymentMethod, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTotalAmountByApikey = `-- name: GetMonthlyTotalAmountByApikey :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time)::integer AS year,
        EXTRACT(MONTH FROM t.transaction_time)::integer AS month,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    INNER JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM $1::timestamp)
        AND m.api_key = $2
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time),
        EXTRACT(MONTH FROM t.transaction_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_amount
    FROM
        monthly_data
    UNION ALL

    SELECT
        EXTRACT(YEAR FROM gs.month)::text AS year,
        TO_CHAR(gs.month, 'Mon') AS month,
        0::integer AS total_amount
    FROM generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '11 month',
        interval '1 month'
    ) AS gs(month)
    WHERE NOT EXISTS (
        SELECT 1 FROM monthly_data md
        WHERE md.year = EXTRACT(YEAR FROM gs.month)::integer
        AND md.month = EXTRACT(MONTH FROM gs.month)::integer
    )
)
SELECT year, month, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthlyTotalAmountByApikeyParams struct {
	Column1 time.Time `json:"column_1"`
	ApiKey  string    `json:"api_key"`
}

type GetMonthlyTotalAmountByApikeyRow struct {
	Year        string `json:"year"`
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthlyTotalAmountByApikey: Retrieves total transaction amounts for the current and previous month
// Purpose: Provide monthly transaction summary including zero values if no transactions exist
// Parameters:
//
//	$1: reference_date - Any date within the target (current) month
//	$2: api-key - The merchant to filter transactions
//
// Returns:
//   - Year (as text)
//   - Month (abbreviated name, e.g., Jan, Feb)
//   - Total transaction amount for each month
//
// Business Logic:
//   - Aggregates total transaction amounts for the target month and the month before
//   - Filters only active (non-deleted) transactions and merchants
//   - Includes 0 as total_amount if there's no transaction data for either month
//   - Uses UNION ALL to combine real data with "missing month" placeholders
//   - Results are sorted by year and month (most recent first)
func (q *Queries) GetMonthlyTotalAmountByApikey(ctx context.Context, arg GetMonthlyTotalAmountByApikeyParams) ([]*GetMonthlyTotalAmountByApikeyRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTotalAmountByApikey, arg.Column1, arg.ApiKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTotalAmountByApikeyRow
	for rows.Next() {
		var i GetMonthlyTotalAmountByApikeyRow
		if err := rows.Scan(&i.Year, &i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTotalAmountByMerchant = `-- name: GetMonthlyTotalAmountByMerchant :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time)::integer AS year,
        EXTRACT(MONTH FROM t.transaction_time)::integer AS month,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    INNER JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM $1::timestamp)
        AND t.merchant_id = $2::integer
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time),
        EXTRACT(MONTH FROM t.transaction_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_amount
    FROM
        monthly_data
    UNION ALL

    SELECT
        EXTRACT(YEAR FROM gs.month)::text AS year,
        TO_CHAR(gs.month, 'Mon') AS month,
        0::integer AS total_amount
    FROM generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '11 month',
        interval '1 month'
    ) AS gs(month)
    WHERE NOT EXISTS (
        SELECT 1 FROM monthly_data md
        WHERE md.year = EXTRACT(YEAR FROM gs.month)::integer
        AND md.month = EXTRACT(MONTH FROM gs.month)::integer
    )
)
SELECT year, month, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthlyTotalAmountByMerchantParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 int32     `json:"column_2"`
}

type GetMonthlyTotalAmountByMerchantRow struct {
	Year        string `json:"year"`
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthlyTotalAmountByMerchant: Retrieves total transaction amounts for the current and previous month
// Purpose: Provide monthly transaction summary including zero values if no transactions exist
// Parameters:
//
//	$1: reference_date - Any date within the target (current) month
//	$2: merchant_id - The merchant to filter transactions
//
// Returns:
//   - Year (as text)
//   - Month (abbreviated name, e.g., Jan, Feb)
//   - Total transaction amount for each month
//
// Business Logic:
//   - Aggregates total transaction amounts for the target month and the month before
//   - Filters only active (non-deleted) transactions and merchants
//   - Includes 0 as total_amount if there's no transaction data for either month
//   - Uses UNION ALL to combine real data with "missing month" placeholders
//   - Results are sorted by year and month (most recent first)
func (q *Queries) GetMonthlyTotalAmountByMerchant(ctx context.Context, arg GetMonthlyTotalAmountByMerchantParams) ([]*GetMonthlyTotalAmountByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTotalAmountByMerchant, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTotalAmountByMerchantRow
	for rows.Next() {
		var i GetMonthlyTotalAmountByMerchantRow
		if err := rows.Scan(&i.Year, &i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTotalAmountMerchant = `-- name: GetMonthlyTotalAmountMerchant :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time)::text AS year,
        TO_CHAR(t.transaction_time, 'Mon') AS month,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    INNER JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND (
            t.transaction_time >= date_trunc('month', $1::timestamp) - interval '1 month'
            AND t.transaction_time < date_trunc('month', $1::timestamp) + interval '1 month'
        )
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time),
        TO_CHAR(t.transaction_time, 'Mon')
), missing_months AS (
    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::text
        AND month = TO_CHAR($1::timestamp, 'Mon')
    )
    UNION ALL
    SELECT
        EXTRACT(YEAR FROM date_trunc('month', $1::timestamp) - interval '1 month')::text AS year,
        TO_CHAR(date_trunc('month', $1::timestamp) - interval '1 month', 'Mon') AS month,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM date_trunc('month', $1::timestamp) - interval '1 month')::text
        AND month = TO_CHAR(date_trunc('month', $1::timestamp) - interval '1 month', 'Mon')
    )
)
SELECT year, month, total_amount
FROM (
    SELECT year, month, total_amount FROM monthly_data
    UNION ALL
    SELECT year, month, total_amount FROM missing_months
) combined
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthlyTotalAmountMerchantRow struct {
	Year        string `json:"year"`
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

// GetMonthlyTotalAmountMerchant: Retrieves total transaction amounts for the current and previous month
// Purpose: Provide monthly transaction summary including zero values if no transactions exist
// Parameters:
//
//	$1: reference_date - Any date within the target (current) month
//
// Returns:
//   - Year (as text)
//   - Month (abbreviated name, e.g., Jan, Feb)
//   - Total transaction amount for each month
//
// Business Logic:
//   - Aggregates total transaction amounts for the target month and the month before
//   - Filters only active (non-deleted) transactions and merchants
//   - Includes 0 as total_amount if there's no transaction data for either month
//   - Uses UNION ALL to combine real data with "missing month" placeholders
//   - Results are sorted by year and month (most recent first)
func (q *Queries) GetMonthlyTotalAmountMerchant(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyTotalAmountMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTotalAmountMerchant, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTotalAmountMerchantRow
	for rows.Next() {
		var i GetMonthlyTotalAmountMerchantRow
		if err := rows.Scan(&i.Year, &i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedMerchantByID = `-- name: GetTrashedMerchantByID :one
SELECT merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at
FROM merchants
WHERE
    merchant_id = $1
    AND deleted_at IS NOT NULL
`

// GetTrashedMerchantByID: Retrieves a soft-deleted merchant by ID
// Purpose: Access trashed merchant record for potential restoration or inspection
// Parameters:
//
//	$1: merchant_id - Unique identifier of the merchant
//
// Returns:
//
//	Trashed merchant record
//
// Business Logic:
//   - Includes only merchants that have been soft-deleted (deleted_at IS NOT NULL)
func (q *Queries) GetTrashedMerchantByID(ctx context.Context, merchantID int32) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, getTrashedMerchantByID, merchantID)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantNo,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedMerchants = `-- name: GetTrashedMerchants :many
SELECT
    merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM merchants
WHERE deleted_at IS NOT NULL
    AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%' OR api_key ILIKE '%' || $1 || '%' OR status ILIKE '%' || $1 || '%')
ORDER BY merchant_id
LIMIT $2 OFFSET $3
`

type GetTrashedMerchantsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedMerchantsRow struct {
	MerchantID int32        `json:"merchant_id"`
	MerchantNo uuid.UUID    `json:"merchant_no"`
	Name       string       `json:"name"`
	ApiKey     string       `json:"api_key"`
	UserID     int32        `json:"user_id"`
	Status     string       `json:"status"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// GetTrashedMerchants: Retrieves paginated list of soft-deleted merchants with search capability
// Purpose: View trashed merchants for potential restoration or permanent deletion
// Parameters:
//
//	$1: search_term - Optional text to filter by name, api_key, or status (NULL for no filter)
//	$2: limit - Maximum number of records to return
//	$3: offset - Number of records to skip for pagination
//
// Returns:
//
//	All merchant fields plus total_count of matching records
//
// Business Logic:
//   - Only includes soft-deleted merchants (deleted_at IS NOT NULL)
//   - Supports partial text search (case-insensitive) on name, api_key, and status
//   - Returns results ordered by merchant_id
//   - Provides total_count for pagination calculations
func (q *Queries) GetTrashedMerchants(ctx context.Context, arg GetTrashedMerchantsParams) ([]*GetTrashedMerchantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedMerchants, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedMerchantsRow
	for rows.Next() {
		var i GetTrashedMerchantsRow
		if err := rows.Scan(
			&i.MerchantID,
			&i.MerchantNo,
			&i.Name,
			&i.ApiKey,
			&i.UserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyAmountByApikey = `-- name: GetYearlyAmountByApikey :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time) AS year,
        SUM(t.amount) AS total_amount
    FROM
        transactions t
    JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND m.api_key = $1
        AND EXTRACT(YEAR FROM t.transaction_time) >= $2 - 4
        AND EXTRACT(YEAR FROM t.transaction_time) <= $2
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time)
)
SELECT
    year,
    total_amount
FROM
    last_five_years
ORDER BY
    year
`

type GetYearlyAmountByApikeyParams struct {
	ApiKey  string      `json:"api_key"`
	Column2 interface{} `json:"column_2"`
}

type GetYearlyAmountByApikeyRow struct {
	Year        string `json:"year"`
	TotalAmount int64  `json:"total_amount"`
}

// GetYearlyAmountByMerchants: Retrieves total transaction amount per year for the last 5 years for a specific merchant
// Purpose: Show overall yearly revenue trends for a merchant across all payment methods
// Parameters:
//
//	$1: api-key - The merchant to filter transactions
//	$2: current_year - The latest year to include in the 5-year window
//
// Returns:
//   - Year (e.g., 2021, 2022)
//   - Total transaction amount
//
// Business Logic:
//   - Filters only active (non-deleted) transactions and merchants
//   - Filters by specific merchant_id
//   - Includes data for the last 5 calendar years up to the current year
//   - Groups by calendar year
//   - Results are ordered chronologically by year
func (q *Queries) GetYearlyAmountByApikey(ctx context.Context, arg GetYearlyAmountByApikeyParams) ([]*GetYearlyAmountByApikeyRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyAmountByApikey, arg.ApiKey, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyAmountByApikeyRow
	for rows.Next() {
		var i GetYearlyAmountByApikeyRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyAmountByMerchants = `-- name: GetYearlyAmountByMerchants :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time) AS year,
        SUM(t.amount) AS total_amount
    FROM
        transactions t
    JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND t.merchant_id = $1
        AND EXTRACT(YEAR FROM t.transaction_time) >= $2 - 4
        AND EXTRACT(YEAR FROM t.transaction_time) <= $2
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time)
)
SELECT
    year,
    total_amount
FROM
    last_five_years
ORDER BY
    year
`

type GetYearlyAmountByMerchantsParams struct {
	MerchantID int32       `json:"merchant_id"`
	Column2    interface{} `json:"column_2"`
}

type GetYearlyAmountByMerchantsRow struct {
	Year        string `json:"year"`
	TotalAmount int64  `json:"total_amount"`
}

// GetYearlyAmountByMerchants: Retrieves total transaction amount per year for the last 5 years for a specific merchant
// Purpose: Show overall yearly revenue trends for a merchant across all payment methods
// Parameters:
//
//	$1: merchant_id - The merchant to filter transactions
//	$2: current_year - The latest year to include in the 5-year window
//
// Returns:
//   - Year (e.g., 2021, 2022)
//   - Total transaction amount
//
// Business Logic:
//   - Filters only active (non-deleted) transactions and merchants
//   - Filters by specific merchant_id
//   - Includes data for the last 5 calendar years up to the current year
//   - Groups by calendar year
//   - Results are ordered chronologically by year
func (q *Queries) GetYearlyAmountByMerchants(ctx context.Context, arg GetYearlyAmountByMerchantsParams) ([]*GetYearlyAmountByMerchantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyAmountByMerchants, arg.MerchantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyAmountByMerchantsRow
	for rows.Next() {
		var i GetYearlyAmountByMerchantsRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyAmountMerchant = `-- name: GetYearlyAmountMerchant :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time) AS year,
        SUM(t.amount) AS total_amount
    FROM
        transactions t
    JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL AND m.deleted_at IS NULL
        AND EXTRACT(YEAR FROM t.transaction_time) >= $1 - 4
        AND EXTRACT(YEAR FROM t.transaction_time) <= $1
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time)
)
SELECT
    year,
    total_amount
FROM
    last_five_years
ORDER BY
    year
`

type GetYearlyAmountMerchantRow struct {
	Year        string `json:"year"`
	TotalAmount int64  `json:"total_amount"`
}

// GetYearlyAmountMerchant: Retrieves total transaction amount per year for the last 5 years
// Purpose: Show overall yearly revenue trends across all payment methods
// Parameters:
//
//	$1: current_year - The latest year to include in the 5-year window
//
// Returns:
//   - Year (e.g., 2021, 2022)
//   - Total transaction amount
//
// Business Logic:
//   - Aggregates yearly transaction amounts
//   - Filters only active (non-deleted) transactions and merchants
//   - Includes data for the last 5 calendar years up to the current year
//   - Ordered chronologically by year
func (q *Queries) GetYearlyAmountMerchant(ctx context.Context, dollar_1 interface{}) ([]*GetYearlyAmountMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyAmountMerchant, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyAmountMerchantRow
	for rows.Next() {
		var i GetYearlyAmountMerchantRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyPaymentMethodByApikey = `-- name: GetYearlyPaymentMethodByApikey :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time) AS year,
        t.payment_method,
        SUM(t.amount) AS total_amount
    FROM
        transactions t
    JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND m.api_key = $1
        AND EXTRACT(YEAR FROM t.transaction_time) >= $2 - 4
        AND EXTRACT(YEAR FROM t.transaction_time) <= $2
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time),
        t.payment_method
)
SELECT
    year,
    payment_method,
    total_amount
FROM
    last_five_years
ORDER BY
    year
`

type GetYearlyPaymentMethodByApikeyParams struct {
	ApiKey  string      `json:"api_key"`
	Column2 interface{} `json:"column_2"`
}

type GetYearlyPaymentMethodByApikeyRow struct {
	Year          string `json:"year"`
	PaymentMethod string `json:"payment_method"`
	TotalAmount   int64  `json:"total_amount"`
}

// GetYearlyPaymentMethodByApikey: Retrieves total transaction amount per payment method over the last 5 years for a specific merchant
// Purpose: Analyze yearly transaction totals grouped by payment method for a merchant
// Parameters:
//
//	$1: api-key - The merchant to filter transactions
//	$2: current_year - The latest year to include in the 5-year window
//
// Returns:
//   - Year (e.g., 2021, 2022)
//   - Payment method
//   - Total transaction amount
//
// Business Logic:
//   - Filters only active (non-deleted) transactions and merchants
//   - Filters by specific merchant_id
//   - Includes data for the last 5 calendar years up to the current year
//   - Groups by calendar year and payment method
//   - Results are ordered chronologically by year
func (q *Queries) GetYearlyPaymentMethodByApikey(ctx context.Context, arg GetYearlyPaymentMethodByApikeyParams) ([]*GetYearlyPaymentMethodByApikeyRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyPaymentMethodByApikey, arg.ApiKey, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyPaymentMethodByApikeyRow
	for rows.Next() {
		var i GetYearlyPaymentMethodByApikeyRow
		if err := rows.Scan(&i.Year, &i.PaymentMethod, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyPaymentMethodByMerchants = `-- name: GetYearlyPaymentMethodByMerchants :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time) AS year,
        t.payment_method,
        SUM(t.amount) AS total_amount
    FROM
        transactions t
    JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND t.merchant_id = $1
        AND EXTRACT(YEAR FROM t.transaction_time) >= $2 - 4
        AND EXTRACT(YEAR FROM t.transaction_time) <= $2
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time),
        t.payment_method
)
SELECT
    year,
    payment_method,
    total_amount
FROM
    last_five_years
ORDER BY
    year
`

type GetYearlyPaymentMethodByMerchantsParams struct {
	MerchantID int32       `json:"merchant_id"`
	Column2    interface{} `json:"column_2"`
}

type GetYearlyPaymentMethodByMerchantsRow struct {
	Year          string `json:"year"`
	PaymentMethod string `json:"payment_method"`
	TotalAmount   int64  `json:"total_amount"`
}

// GetYearlyPaymentMethodByMerchants: Retrieves total transaction amount per payment method over the last 5 years for a specific merchant
// Purpose: Analyze yearly transaction totals grouped by payment method for a merchant
// Parameters:
//
//	$1: current_year - The latest year to include in the 5-year window
//	$2: merchant_id - The merchant to filter transactions
//
// Returns:
//   - Year (e.g., 2021, 2022)
//   - Payment method
//   - Total transaction amount
//
// Business Logic:
//   - Filters only active (non-deleted) transactions and merchants
//   - Filters by specific merchant_id
//   - Includes data for the last 5 calendar years up to the current year
//   - Groups by calendar year and payment method
//   - Results are ordered chronologically by year
func (q *Queries) GetYearlyPaymentMethodByMerchants(ctx context.Context, arg GetYearlyPaymentMethodByMerchantsParams) ([]*GetYearlyPaymentMethodByMerchantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyPaymentMethodByMerchants, arg.MerchantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyPaymentMethodByMerchantsRow
	for rows.Next() {
		var i GetYearlyPaymentMethodByMerchantsRow
		if err := rows.Scan(&i.Year, &i.PaymentMethod, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyPaymentMethodMerchant = `-- name: GetYearlyPaymentMethodMerchant :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time) AS year,
        t.payment_method,
        SUM(t.amount) AS total_amount
    FROM
        transactions t
    JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL AND m.deleted_at IS NULL
        AND EXTRACT(YEAR FROM t.transaction_time) >= $1 - 4
        AND EXTRACT(YEAR FROM t.transaction_time) <= $1
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time),
        t.payment_method
)
SELECT
    year,
    payment_method,
    total_amount
FROM
    last_five_years
ORDER BY
    year
`

type GetYearlyPaymentMethodMerchantRow struct {
	Year          string `json:"year"`
	PaymentMethod string `json:"payment_method"`
	TotalAmount   int64  `json:"total_amount"`
}

// GetYearlyPaymentMethodMerchant: Retrieves yearly transaction totals per payment method (last 5 years)
// Purpose: Show transaction trends across payment methods over the past 5 years
// Parameters:
//
//	$1: current_year - The latest year to include in the 5-year window
//
// Returns:
//   - Year (e.g., 2021, 2022)
//   - Payment method
//   - Total transaction amount
//
// Business Logic:
//   - Aggregates yearly totals for each payment method
//   - Includes only active (non-deleted) transactions and merchants
//   - Covers a 5-year range: (current_year - 4) to current_year
//   - Ordered by year
func (q *Queries) GetYearlyPaymentMethodMerchant(ctx context.Context, dollar_1 interface{}) ([]*GetYearlyPaymentMethodMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyPaymentMethodMerchant, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyPaymentMethodMerchantRow
	for rows.Next() {
		var i GetYearlyPaymentMethodMerchantRow
		if err := rows.Scan(&i.Year, &i.PaymentMethod, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTotalAmountByApikey = `-- name: GetYearlyTotalAmountByApikey :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time)::integer AS year,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    INNER JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND EXTRACT(YEAR FROM t.transaction_time) >= $1::integer - 4
        AND EXTRACT(YEAR FROM t.transaction_time) <= $1::integer
        AND m.api_key = $2
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time)
), formatted_data AS (
    SELECT
        year::text,
        total_amount
    FROM
        yearly_data
    UNION ALL

    SELECT
        y::text AS year,
        0::integer AS total_amount
    FROM generate_series($1::integer - 4, $1::integer) AS y
    WHERE NOT EXISTS (
        SELECT 1 FROM yearly_data yd
        WHERE yd.year = y
    )
)
SELECT year, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTotalAmountByApikeyParams struct {
	Column1 int32  `json:"column_1"`
	ApiKey  string `json:"api_key"`
}

type GetYearlyTotalAmountByApikeyRow struct {
	Year        string `json:"year"`
	TotalAmount int32  `json:"total_amount"`
}

// GetYearlyTotalAmountByApikey: Retrieves total transaction amounts for the current and previous year
// Purpose: Provide yearly transaction summary with fallback to 0 if no transactions exist
// Parameters:
//
//	$1: current_year - The latest year to include in the summary
//	$2: api-key - The merchant to filter transactions
//
// Returns:
//   - Year (as text)
//   - Total transaction amount per year
//
// Business Logic:
//   - Aggregates total amounts for both the current year and the previous year
//   - Filters only active (non-deleted) transactions and merchants
//   - Ensures both years appear in the result, even if no data exists (returns 0 in such case)
//   - Uses UNION ALL to combine actual data with 0-filled placeholders
//   - Results are ordered in descending order by year
func (q *Queries) GetYearlyTotalAmountByApikey(ctx context.Context, arg GetYearlyTotalAmountByApikeyParams) ([]*GetYearlyTotalAmountByApikeyRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTotalAmountByApikey, arg.Column1, arg.ApiKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTotalAmountByApikeyRow
	for rows.Next() {
		var i GetYearlyTotalAmountByApikeyRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTotalAmountByMerchant = `-- name: GetYearlyTotalAmountByMerchant :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time)::integer AS year,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    INNER JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND EXTRACT(YEAR FROM t.transaction_time) >= $1::integer - 4
        AND EXTRACT(YEAR FROM t.transaction_time) <= $1::integer
        AND t.merchant_id = $2::integer
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time)
), formatted_data AS (
    SELECT
        year::text,
        total_amount
    FROM
        yearly_data
    UNION ALL

    SELECT
        y::text AS year,
        0::integer AS total_amount
    FROM generate_series($1::integer - 4, $1::integer) AS y
    WHERE NOT EXISTS (
        SELECT 1 FROM yearly_data yd
        WHERE yd.year = y
    )
)
SELECT year, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTotalAmountByMerchantParams struct {
	Column1 int32 `json:"column_1"`
	Column2 int32 `json:"column_2"`
}

type GetYearlyTotalAmountByMerchantRow struct {
	Year        string `json:"year"`
	TotalAmount int32  `json:"total_amount"`
}

// GetYearlyTotalAmountByMerchant: Retrieves total transaction amounts for the current and previous year
// Purpose: Provide yearly transaction summary with fallback to 0 if no transactions exist
// Parameters:
//
//	$1: current_year - The latest year to include in the summary
//	$2: merchant_id - The merchant to filter transactions
//
// Returns:
//   - Year (as text)
//   - Total transaction amount per year
//
// Business Logic:
//   - Aggregates total amounts for both the current year and the previous year
//   - Filters only active (non-deleted) transactions and merchants
//   - Ensures both years appear in the result, even if no data exists (returns 0 in such case)
//   - Uses UNION ALL to combine actual data with 0-filled placeholders
//   - Results are ordered in descending order by year
func (q *Queries) GetYearlyTotalAmountByMerchant(ctx context.Context, arg GetYearlyTotalAmountByMerchantParams) ([]*GetYearlyTotalAmountByMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTotalAmountByMerchant, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTotalAmountByMerchantRow
	for rows.Next() {
		var i GetYearlyTotalAmountByMerchantRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTotalAmountMerchant = `-- name: GetYearlyTotalAmountMerchant :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time)::integer AS year,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    INNER JOIN
        merchants m ON t.merchant_id = m.merchant_id
    WHERE
        t.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND (
            EXTRACT(YEAR FROM t.transaction_time) = $1::integer
            OR EXTRACT(YEAR FROM t.transaction_time) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time)
), formatted_data AS (
    SELECT
        year::text,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTotalAmountMerchantRow struct {
	Year        string `json:"year"`
	TotalAmount int32  `json:"total_amount"`
}

// GetYearlyTotalAmountMerchant: Retrieves total transaction amounts for the current and previous year
// Purpose: Provide yearly transaction summary with fallback to 0 if no transactions exist
// Parameters:
//
//	$1: current_year - The latest year to include in the summary
//
// Returns:
//   - Year (as text)
//   - Total transaction amount per year
//
// Business Logic:
//   - Aggregates total amounts for both the current year and the previous year
//   - Filters only active (non-deleted) transactions and merchants
//   - Ensures both years appear in the result, even if no data exists (returns 0 in such case)
//   - Uses UNION ALL to combine actual data with 0-filled placeholders
//   - Results are ordered in descending order by year
func (q *Queries) GetYearlyTotalAmountMerchant(ctx context.Context, dollar_1 int32) ([]*GetYearlyTotalAmountMerchantRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTotalAmountMerchant, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTotalAmountMerchantRow
	for rows.Next() {
		var i GetYearlyTotalAmountMerchantRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllMerchants = `-- name: RestoreAllMerchants :exec
UPDATE merchants
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Merchants
// Purpose: Restore all merchants that are soft deleted
// Business Logic:
//   - Resets the `deleted_at` field to NULL for all merchants that have been marked as deleted.
//   - Restores all merchants to an active state.
func (q *Queries) RestoreAllMerchants(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllMerchants)
	return err
}

const restoreMerchant = `-- name: RestoreMerchant :one
UPDATE merchants
SET
    deleted_at = NULL
WHERE
    merchant_id = $1
    AND deleted_at IS NOT NULL
RETURNING merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at
`

// Restore Trashed Merchant
// Purpose: Restore a previously trashed (soft deleted) merchant
// Parameters:
//
//	$1: merchant_id - ID of the merchant to restore
//
// Business Logic:
//   - Resets the `deleted_at` field to NULL, restoring the merchant to an active state.
//   - Ensures the merchant is currently trashed (deleted_at is not NULL).
func (q *Queries) RestoreMerchant(ctx context.Context, merchantID int32) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, restoreMerchant, merchantID)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantNo,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashMerchant = `-- name: TrashMerchant :one
UPDATE merchants
SET
    deleted_at = current_timestamp
WHERE
    merchant_id = $1
    AND deleted_at IS NULL
RETURNING merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at
`

// Trash Merchant
// Purpose: Mark a merchant as deleted (soft delete)
// Parameters:
//
//	$1: merchant_id - ID of the merchant to be trashed
//
// Business Logic:
//   - Sets the `deleted_at` timestamp to the current time for the specified merchant.
//   - Marks the merchant as deleted, without permanently removing it from the database.
//   - Ensures the merchant is not already marked as deleted (deleted_at is NULL).
func (q *Queries) TrashMerchant(ctx context.Context, merchantID int32) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, trashMerchant, merchantID)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantNo,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateMerchant = `-- name: UpdateMerchant :one
UPDATE merchants
SET
    name = $2,
    user_id = $3,
    status = $4,
    updated_at = current_timestamp
WHERE
    merchant_id = $1
    AND deleted_at IS NULL
RETURNING merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at
`

type UpdateMerchantParams struct {
	MerchantID int32  `json:"merchant_id"`
	Name       string `json:"name"`
	UserID     int32  `json:"user_id"`
	Status     string `json:"status"`
}

// Update Merchant
// Purpose: Update an existing merchant record
// Parameters:
//
//	$1: merchant_id - ID of the merchant to be updated
//	$2: name - The new name for the merchant
//	$3: user_id - New user ID associated with the merchant
//	$4: status - New status for the merchant
//
// Business Logic:
//   - Updates the specified merchant's name, user_id, and status.
//   - Ensures the merchant is not marked as deleted (deleted_at is NULL).
//   - Sets the updated_at timestamp to the current time.
func (q *Queries) UpdateMerchant(ctx context.Context, arg UpdateMerchantParams) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, updateMerchant,
		arg.MerchantID,
		arg.Name,
		arg.UserID,
		arg.Status,
	)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantNo,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateMerchantStatus = `-- name: UpdateMerchantStatus :one
UPDATE merchants
SET
    status = $2,
    updated_at = current_timestamp
WHERE
    merchant_id = $1
    AND deleted_at IS NULL
RETURNING merchant_id, merchant_no, name, api_key, user_id, status, created_at, updated_at, deleted_at
`

type UpdateMerchantStatusParams struct {
	MerchantID int32  `json:"merchant_id"`
	Status     string `json:"status"`
}

// Purpose: Update only the status of an existing merchant
// Parameters:
//
//	$1: merchant_id - ID of the merchant to update
//	$2: status - New status to set for the merchant
//
// Business Logic:
//   - Updates the status of the specified merchant.
//   - Ensures the merchant is not marked as deleted (deleted_at is NULL).
//   - Sets the updated_at timestamp to the current time.
func (q *Queries) UpdateMerchantStatus(ctx context.Context, arg UpdateMerchantStatusParams) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, updateMerchantStatus, arg.MerchantID, arg.Status)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.MerchantNo,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
